## synchronized
在方法上加synchronized 互斥锁保证某个时间点不会有另一个线程访问当前锁住对象的同步方法，但可以访问其他未加锁的方法。

## Lock
#### ReentrantLock
公平锁，每一次的tryAcquire都会检查CLH队列中是否仍有前驱的元素，如果仍然有那么继续等待，通过这种方式来保证先来先服务的原则。  
非公平锁，首先是检查并设置锁的状态，这种方式会出现即使队列中有等待的线程，但是新的线程仍然会与排队线程中的队头线程竞争（但是排队的线程是先来先服务的），所以新的线程可能会抢占已经在排队的线程的锁，这样就无法保证先来先服务，但是已经等待的线程是仍然保证先来先服务的。
> 公平锁：老的线程排队使用锁，新线程仍然排队使用锁。  
> 非公平锁：老的线程排队使用锁；但是无法保证新线程抢占已经在排队的线程的锁。

- lock()：获取锁标记的时候，如果需要阻塞等待锁标记，无法被打断。
- lockInterruptibly()：获取锁标记的时候，如果需要阻塞等待，可以被打断。

## 区别
- 等待可中断  
当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
- 公平锁  
synchronized是非公平锁，ReentrantLock默认也是非公平锁，可以设置为公平锁。
- 锁绑定条件  
一个ReentrantLock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果需要多个条件关联时，需要额外添加锁，ReentrantLock只需多次调用newCondition()即可。