#### 多进程和多线程的本质区别在于每个进程拥有自己的一整套变量，而线程则共享数据。

Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。

Java中有两类线程：用户线程 (User Thread)、守护线程 (Daemon Thread)。
- 守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。因此，当所有的非守护线程结束时，程序也就终止了，同时会杀死进程中的所有守护线程。反过来说，只要任何非守护线程还在运行，程序就不会终止。
- 用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了， 虚拟机也就退出了。因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。
- 将线程转换为守护线程可以通过调用Thread对象的setDaemon(true)方法来实现。在使用守护线程时需要注意一下几点：
    1. thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。
	2. 在Daemon线程中产生的新线程也是Daemon的。
	3. 守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。

> 启动线程 start()方法。直接调用run()方法就是方法调用。  
> run()结束 线程就结束了。
#### 创建线程方法
1. 实现Runnable接口。实现 void run()方法。
2. 继承Thread类。重写 void run()方法。
3. 线程池。实现 Callable 的 V call()方法
> 实现Runnable接口的方式相对好些，首先Java是单继承，继承了Thread类之后就不能再继承其他业务类。但可以实现多个接口。从面向对象的思想考虑，线程任务是一个对象，线程是一个对象。

- Executor  
是Runnable和Callable的调度容器，Future就是对于具体的调度任务的执行结果进行查看，最为关键的是Future可以检查对应的任务是否已经完成，也可以阻塞在get方法上一直等待任务返回结果。
Runnable和Callable的区别就是Runnable是没有结果可以返回的，就算是通过Future也看不到任务调度的结果的。

- FutureTask  
多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。  
单独使用Runnable时：无法获得返回值。  
单独使用Callable时：无法在线程中(new Thread(Runnable r))使用，只能使用ExecutorService。Thread类只支持Runnable。
> FutureTask：实现了Runnable和Future，所以兼顾两者优点。既可以使用ExecutorService，也可以使用Thread。

#### wait()和sleep()的区别
1. wait()是Object类的方法，sleep()是Thread类的方法。
2. wait()使用之前必须锁定对象，会释放这个对象的锁，要等着被唤醒，否则一直等待。sleep()抱着锁睡一定时间，自己唤醒。
#### main 主线程
JVM 的关闭是由是否还存在非守护线程决定。
1. 如果mian方法里创建的是守护线程，main 方法不等线程执行完成会提前结束。
2. junit测试时@test方法执行完就会终止所有用户线程。
#### 线程安全
当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。
> 互斥是因，同步是果；互斥是方法，同步是目的。
#### 并行和并发
