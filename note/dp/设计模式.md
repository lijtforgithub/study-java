## 创建型模式
#### 单例模式
1. 如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。
2. 如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。
#### 工厂模式
* 简单工厂
* 工厂方法
* 抽象工厂
#### 调停者模式 
**mediator**
> 消息中间件：MQ
#### 门面模式

## 行为模式
#### 策略模式
**strategy**
主要解决在有**多种算法相似**的情况下，使用 if...else 所带来的复杂和难以维护。定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
- 优点 
    1. 算法可以自由切换。 
    2. 避免使用多重条件判断。 
    3. 扩展性良好。
- 缺点
    1. 策略类会增多。 
    2. 所有策略类都需要对外暴露。
> java.util.Comparator
#### 访问者模式
**visitor**
主要解决**稳定的数据结构**和易变的操作耦合问题。将数据结构与数据操作分离。
- 优点
    1. 符合单一职责原则。 
    2. 优秀的扩展性。 
    3. 灵活性。

- 缺点
    1. 具体元素对访问者公布细节，违反了迪米特原则。 
    2. 具体元素变更比较困难。 
    3. 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。