- 多用组合 少用继承
- 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
- 为了交互对象之间的松耦合设计而努力。  
松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。
- 类应该对扩展开放，对修改关闭。
- 依赖倒置原则：要依赖抽象，不要依赖具体类。
- 最少知识原则：只和你的密友谈话。
   
- 装饰者：不改变接口，但加入责任。
- 适配器：将一个接口转成另一个接口。
- 外观：让接口更简单。
   	
- 模板方法：子类决定如何实现算法中的步骤。
- 策略：封装可互换的行为，然后使用委托来决定要采用哪一个行为。
- 工厂方法：由子类决定实例化哪个具体类。
   	
## 创建型模式
#### 单例模式
1. 如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。
2. 如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。
#### 原型模式
**prototype** 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
- 优点  
性能优良。原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，
特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。
- 缺点  
逃避构造函数的约束。这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。
#### 工厂模式
* 简单工厂
* 工厂方法
* 抽象工厂
#### 调停者模式 
**mediator**
> 消息中间件：MQ
#### 门面模式

## 结构型模式
#### 装饰器模式
**decorator** 主要解决一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

装饰器模式：装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。
 	 
> java.io 包中用到此模式
- 装饰模式和桥接模式的区别：
两个模式都是为了解决过多子类对象的问题，桥接模式是对象自身有过多的维度，造成过多的子类。而让维度分类后在搭建一个桥梁来联系起来。而装饰模式是解决在增加新功能的时候产生多个类的问题。
#### 过滤器模式
**filter** 
#### 代理模式
**proxy** 为其他对象提供一种代理以控制对这个对象的访问。
#### 适配器模式
**adapter** 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  
有新的行为或责任要加入，装饰者模式。
#### 外观模式
**facade** 提供了一个统一的接口，用来放访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

## 行为模式
#### 观察者模式
**observer** 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
#### 模板模式
**template** 主要解决一些方法通用，却在每一个子类都重新写了这一方法。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
> java.lang.ClassLoader
#### 状态模式
**state** 主要解决对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。
#### 迭代器模式
**iterator** 主要解决不同的方式来遍历整个整合对象。提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示
> java.util.Iterator
#### 策略模式
**strategy**
主要解决在有**多种算法相似**的情况下，使用 if...else 所带来的复杂和难以维护。定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
- 优点 
    1. 算法可以自由切换。 
    2. 避免使用多重条件判断。 
    3. 扩展性良好。
- 缺点
    1. 策略类会增多。 
    2. 所有策略类都需要对外暴露。
> java.util.Comparator
#### 访问者模式
**visitor**
主要解决**稳定的数据结构**和易变的操作耦合问题。将数据结构与数据操作分离。
- 优点
    1. 符合单一职责原则。 
    2. 优秀的扩展性。 
    3. 灵活性。

- 缺点
    1. 具体元素对访问者公布细节，违反了迪米特原则。 
    2. 具体元素变更比较困难。 
    3. 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。