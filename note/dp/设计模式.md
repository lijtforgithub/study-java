- 多用组合 少用继承
- 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
- 为了交互对象之间的松耦合设计而努力。  
松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。
- 类应该对扩展开放，对修改关闭。
- 依赖倒置原则：要依赖抽象，不要依赖具体类。
- 最少知识原则：只和你的密友谈话。
   
- 装饰者：不改变接口，但加入责任。
- 适配器：将一个接口转成另一个接口。
- 外观：让接口更简单。
   	
- 模板方法：子类决定如何实现算法中的步骤。
- 策略：封装可互换的行为，然后使用委托来决定要采用哪一个行为。
- 工厂方法：由子类决定实例化哪个具体类。
   	
## 创建型模式
#### 单例模式
1. 如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。
2. 如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。
#### 工厂模式
* 简单工厂
* 工厂方法
* 抽象工厂
#### 调停者模式 
**mediator**
> 消息中间件：MQ
#### 门面模式

## 结构型模式
#### 代理模式
**proxy** 为其他对象提供一种代理以控制对这个对象的访问。
#### 适配器模式
**adapter** 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  
有新的行为或责任要加入，装饰者模式。
#### 外观模式
**facade** 提供了一个统一的接口，用来放访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

## 行为模式
#### 模板模式
**template** 主要解决一些方法通用，却在每一个子类都重新写了这一方法。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
> java.lang.ClassLoader
#### 状态模式
**state** 主要解决对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。
#### 迭代器模式
**iterator** 主要解决不同的方式来遍历整个整合对象。提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示
> java.util.Iterator
#### 策略模式
**strategy**
主要解决在有**多种算法相似**的情况下，使用 if...else 所带来的复杂和难以维护。定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
- 优点 
    1. 算法可以自由切换。 
    2. 避免使用多重条件判断。 
    3. 扩展性良好。
- 缺点
    1. 策略类会增多。 
    2. 所有策略类都需要对外暴露。
> java.util.Comparator
#### 访问者模式
**visitor**
主要解决**稳定的数据结构**和易变的操作耦合问题。将数据结构与数据操作分离。
- 优点
    1. 符合单一职责原则。 
    2. 优秀的扩展性。 
    3. 灵活性。

- 缺点
    1. 具体元素对访问者公布细节，违反了迪米特原则。 
    2. 具体元素变更比较困难。 
    3. 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。