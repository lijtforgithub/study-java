- 多用组合 少用继承
- 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。
- 为了交互对象之间的松耦合设计而努力。  
松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到了最低。
- 类应该对扩展开放，对修改关闭。
- 依赖倒置原则：要依赖抽象，不要依赖具体类。
- 最少知识原则：只和你的密友谈话。
   
- 装饰者：不改变接口，但加入责任。
- 适配器：将一个接口转成另一个接口。
- 外观：让接口更简单。
   	
- 模板方法：子类决定如何实现算法中的步骤。
- 策略：封装可互换的行为，然后使用委托来决定要采用哪一个行为。
- 工厂方法：由子类决定实例化哪个具体类。
   	
## 创建型模式
#### 单例模式
1. 如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。
2. 如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。
#### 工厂模式
**factory**
1. 简单工厂模式  
只有一个工厂类一个生产方法，根据参数不同生产不同的产品。
    - 优点：简单，结合单例模式更加方便和节省资源。
 	- 缺点：增加新的产品时，需要修改工厂类的if…else逻辑，不符合开闭原则。
2. 工厂方法模式  
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。每一个工厂类只负责一个产品生产，不生成其它产品。好比一条生产线只生产一个产品线。
   	1. 首先，良好的封装性，代码结构清晰。一个对象创建是有条件约束的，如一个调用者需要一个具体的产品对象，只要知道这个产品的类名（或约束字符串）就可以了，不用知道创建对象的艰辛过程，降低模块间的耦合。
    2. 工厂方法模式是典型的解耦框架。高层模块只需要知道产品的抽象类，其他的实现类都不用关心，符合迪米特法则，我不需要的就不要去交流；
   	3. 也符合依赖倒置原则，只依赖产品类的抽象；当然也符合里氏替换原则，使用产品子类替换产品父类，没问题！
3. 抽象工厂模式  
提供一个接口，用于创建相关或依赖对象的**家族**，而不需要明确指定具体类。
    > 产品家族
#### 原型模式
**prototype** 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
- 优点  
性能优良。原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，
特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。
- 缺点  
逃避构造函数的约束。这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。
#### 工厂模式
* 简单工厂
* 工厂方法
* 抽象工厂
#### 调停者模式 
**mediator**
> 消息中间件：MQ
#### 门面模式

## 结构型模式
#### 装饰器模式
**decorator** 主要解决为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

装饰器模式：装饰模式是在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。
 	 
> java.io 包中用到此模式
1. 装饰者和被装饰对象有相同的超类型。
2. 你可以用一个或多个装饰者包装一个对象。
3. 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象(被包装的)的场合，可以用装饰过的对象代替它。
4. 装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。
5. 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。
#### 桥接模式
**bridge**强调包含代替继承。将抽象部分与实现部分分离，使它们都可以独立的变化。
主要解决在有多种可能会变化的情况下，用继承会造成类爆炸问题，扩展起来不灵活。
> Collections.sort()方法

> 装饰模式和桥接模式的区别：
两个模式都是为了解决过多子类对象的问题，桥接模式是对象自身有过多的维度，造成过多的子类。**而让维度分类后在搭建一个桥梁来联系起来**。而装饰模式是解决在增加新功能的时候产生多个类的问题。
#### 过滤器模式
**filter** 
#### 代理模式
**proxy** 为其他对象提供一种代理以控制对这个对象的访问。
#### 适配器模式
**adapter** 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  
有新的行为或责任要加入，装饰者模式。
#### 外观模式
**facade** 提供了一个统一的接口，用来放访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

## 行为模式
#### 观察者模式
**observer** 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
#### 模板模式
**template** 主要解决一些方法通用，却在每一个子类都重新写了这一方法。定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
> java.lang.ClassLoader
#### 状态模式
**state** 主要解决对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。
#### 迭代器模式
**iterator** 主要解决不同的方式来遍历整个整合对象。提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示
> java.util.Iterator
#### 策略模式
**strategy**
主要解决在有**多种算法相似**的情况下，使用 if...else 所带来的复杂和难以维护。定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
- 优点 
    1. 算法可以自由切换。 
    2. 避免使用多重条件判断。 
    3. 扩展性良好。
- 缺点
    1. 策略类会增多。 
    2. 所有策略类都需要对外暴露。
> java.util.Comparator
#### 访问者模式
**visitor**
主要解决**稳定的数据结构**和易变的操作耦合问题。将数据结构与数据操作分离。
- 优点
    1. 符合单一职责原则。 
    2. 优秀的扩展性。 
    3. 灵活性。

- 缺点
    1. 具体元素对访问者公布细节，违反了迪米特原则。 
    2. 具体元素变更比较困难。 
    3. 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。
#### 命令模式
**command**将请求封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。
- 优点
    1. 降低对象之间的耦合度。
 	2. 新的命令可以很容易地加入到系统中。
 	3. 可以比较容易地设计一个组合命令。
 	4. 调用同一方法实现不同的功能
- 缺点
 	1. 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。