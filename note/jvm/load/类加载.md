### 类加载-初始化
#### 1.加载（Loading）  
*把二进制字节码文件加载到内存。*
- Bootstrap Classloader 由JVM实现，在Java里没有一个类型与之对应，所以访问的时候为null。 
- 双亲委派：主要出于安全来考虑，节约资源。
- ClassLoader源码：findLoadedClass -> parent.loadClass -> findClass()
- 懒加载（LazyLoading）：严格讲是Lazy Initializing。按需加载。  
    + new getstatic putstatic invokestatic指令，访问final变量除外。  
    + java.lang.reflect对类进行反射调用时。  
    + 初始化子类的时候，父类首先初始化。  
    + 虚拟机启动时，被执行的主类必须初始化。
    + 动态语言支持java.lang.invoke.MethodHandle解析的结果为REF_getstatic REF_putstatic REF_invokestatic的方法句柄时，该类必须初始化
- 执行方式：混合执行/编译执行/解释执行  
检测热点代码：-XX:CompileThreshold = 10000
> 把自定义的类的class文件放到JAVA_HOME/jre/classes/，会被Bootstrap ClassLoader加载。（必须是class文件）  
> 把自定义的类的class文件导出成jar放到JAVA_HOME/jre/lib/ext/，会被ExtClassLoader加载。（必须是jar文件）

> 加载器和父加载器不是继承关系，有个parent（final修饰，不可更改）变量指向父加载器。
比如：AppClassLoader的父加载器是ExtClassLoader，但是实际实现两者都是继承自URLClassLoader的。
**父加载器不是类加载器的加载器（自定义类加载除外），也不是类加载器的父类加载器**。
> 当一个类被load内存之后，有两部分内容，class二进制文件和这个class的对象。
一个Classloader的class对象是单例的。
#### 2.连接（Linking）
1. 验证（Verification）：验证文件是否符合JVM规定。
2. 准备（Preparation）：静态成员变量赋默认值。
3. 解析（Resolution）：
    将类、方法、属性等符号引用解析为直接引用；常量池中的各种符号引用解析为指针、偏移量等内存地址的直接引用。
#### 3.初始化（Initializing）  
*静态变量赋初始值；执行静态语句块。*
    
### Tomcat 类加载器
Tomcat自定义类加载器，打破双亲委托原因：
- webapp隔离：由于各个webapp中的class和lib文件需要相互隔离，不能出现一个应用中加载的类库会影响到另一个应用的情况。
- 安全性：与Jvm相同，tomcat也期望使用单独的ClassLoader去装载Tomcat自身的类库，以免其他恶意或者无意的破坏。
- 热部署：Tomcat修改文件可以不用重启自动装载类库。

    
