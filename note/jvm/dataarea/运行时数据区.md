### 指令集分类
1. 基于寄存器的指令集
2. 基于栈的指令集  
   Hotspot中的Local Variable Table 相当于 JVM中的寄存器
### 运行时数据区

| 名称 | 特性 | 作用 | 参数 | 异常 |
|---|---|---|---|---|
| 程序计数器 | 线程私有，生命周期与线程相同，占用内存小。| 当前线程所执行的字节码的行号指示器。为了线程切换后能恢复到正确的执行位置。本地（native）方法，计数器值则为空。| 无 | 无 |
| 虚拟机栈 | 线程私有，生命周期与线程相同，使用连续的内存空间。默认每个线程1MB（JDK1.5）。大部分虚拟机的栈可以**动态扩展**。| 方法执行的内存模型，存储**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息。局部变量表所需内存空间在编译时期完成，运行期间不会改变 | -Xss | StackOverflowError OutOfMemoryError |
| 本地方法栈 | HotSpot虚拟和虚拟机栈合二为一 | 执行本地方法。|  |  |
| 堆 | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址。| 保存实例，大多数对象实例（包括数组）都在堆上分配。GC主要区域。（逃逸技术、标量替换技术带来栈上分配、TLAB实例）| -Xms -Xmx -Xmn | OutOfMemoryError |
| 方法区 | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址。| 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。| -XX:PermSize:16M -XX:MaxPermSize:64M | OutOfMemoryError |
| *运行时常量池* | 方法区的一部分，具有动态性。| 存放字面量及符号引用。运行期间也可将新的常量放到池中，利用String类的intern()方法。 |  |  |
1. 程序计数器（PC）：虚拟机的运行，类似于这样的循环：
    ```
    while ( not end ) {
        取PC中的位置，找到对应位置的指令；
        执行该指令；
        PC ++;
    }
    ```
2. 虚拟机栈（VM Stack）：每一个线程有一个虚拟机栈。一个方法对应一个栈帧。
- 栈帧（Frame）
  + 局部变量表（Local Variable Table）  
    实例方法，下标0为this；然后形参；然后方法内的局部变量。
  + 操作数栈（Operand Stack）  
    对于long的处理（store and load），多数虚拟机的实现都是原子的；jls 17.7，没必要加volatile。
  + 动态链接（Dynamic Linking）  
    
    jvms 2.6.3
  + 方法出口（return address）  
    a() -> b()，方法a调用了方法b, b方法的返回值放在什么地方。
### 常见指令
- invokeinterface：用以调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。
- invokestatic：用以调用类（静态）方法。
- invokevirtual：指令用于调用对象的实例方法，根据对象的实际类型进行分派。（多态）
- invokespecial：指令用于调用一些需要特殊处理的实例方法，包括构造方法、私有方法和父类方法。
- invokedynamic：JDK1.7新加入的一个虚拟机指令，相比于之前的四条指令，他们的分派逻辑都是固化在JVM内部，而invokedynamic则用于处理新的方法分派：它允许应用级别的代码来确定执行哪一个方法调用，只有在调用要执行的时候，才会进行这种判断,从而达到动态语言的支持。  
Lambda表达式或者反射或者其他动态语言scala kotlin，或者CGLib ASM，动态产生的class，会用到的指令。
