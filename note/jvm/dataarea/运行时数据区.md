### 指令集分类
1. 基于寄存器的指令集  
速度相对快一点，主流物理机都是寄存器架构。
2. 基于栈的指令集  
可移植。  
Hotspot中的Local Variable Table 相当于 JVM中的寄存器。
### 运行时数据区

| 名称 | 特性 | 作用 | 参数 | 异常 |
|---|---|---|---|---|
| 程序计数器 | 线程私有，生命周期与线程相同，占用内存小。| 当前线程所执行的字节码的行号指示器。为了线程切换后能恢复到正确的执行位置。本地（native）方法，计数器值则为空。| 无 | 无 |
| 虚拟机栈 | 线程私有，生命周期与线程相同，使用**连续的内存空间**。默认每个线程1MB（JDK1.5）。大部分虚拟机的栈可以**动态扩展**。| 方法执行的内存模型，存储**局部变量表**、**操作数栈**、**动态链接**、**方法出口**等信息。| -Xss | StackOverflowError OutOfMemoryError |
| 本地方法栈 | HotSpot虚拟和虚拟机栈合二为一 | 执行本地方法。|  |  |
| 堆 | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址。| 保存实例，大多数对象实例（包括数组）都在堆上分配。GC主要区域。（逃逸技术、标量替换技术带来栈上分配、TLAB实例）| -Xms -Xmx -Xmn | OutOfMemoryError |
| 方法区 | 线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址。| 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。| -XX:PermSize:16M -XX:MaxPermSize:64M | OutOfMemoryError |
| *运行时常量池* | 方法区的一部分，具有动态性。| 存放字面量及符号引用。运行期间也可将新的常量放到池中，利用String类的intern()方法。 |  |  |
1. 程序计数器（PC）：虚拟机的运行，类似于这样的循环：
    ```
    while ( not end ) {
        取PC中的位置，找到对应位置的指令；
        执行该指令；
        PC ++;
    }
    ```
2. 虚拟机栈（VM Stack）：每一个线程有一个虚拟机栈。一个方法对应一个栈帧。
- 栈帧（Frame）  
支持虚拟机进行方法调用和方法执行的数据结构，虚拟机栈的栈元素。每个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。  
局部变量表的大小，操作数栈的深度在编译时期已经确定了，写入到方法表的Code属性之中；运行期间不会改变。
  1. 局部变量表（Local Variable Table）  
    虚拟机通过索引定位方式使用局部变量表，索引n代表使用第n个slot。  
    实例方法，下标0为隐式参数this；然后形参；然后方法体内的局部变量。  
    *局部变量和成员变量不一样；没有默认值。编译期会检查*。
  2. 操作数栈（Operand Stack）  
    32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。  
    操作数栈共享区域：在概念模型中，两个栈帧作为虚拟机栈的元素，是完全相互独立的。但是大多虚拟机的实现都会做一些优化处理，令两个栈帧出现一部分重叠；无须进行额外的参数复制传递。  
    *Java虚拟机的解释执行引擎称为基于栈的执行引擎，栈指的就是操作数栈*。  
    对于long的处理（store and load），多数虚拟机的实现都是原子的；jls 17.7，没必要加volatile。
  3. [动态链接](https://blog.csdn.net/qq_41813060/article/details/88379473)（Dynamic Linking）  
    class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，称为静态解析。  
 解析的前提是：方法在程序真正运行之前就是一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在编译时就必须确定下来。主要包括静态方法和私有方法两大类。  
 另外一部分将在每一次运行期间转化为直接引用（方法在实际运行时内存布局入口地址），这部分称为动态链接。  
    jvms 2.6.3
  4. 方法返回地址（return address）  
    a() -> b()，方法a调用了方法b, b方法的返回值放在什么地方。  
    方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。
### 常见指令
- invokeinterface：用以调用接口方法，在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。
- invokestatic：用以调用类（静态）方法。
- invokevirtual：指令用于调用对象的实例方法，根据对象的实际类型进行分派。（多态）
- invokespecial：指令用于调用一些需要特殊处理的实例方法，包括构造方法、私有方法和父类方法。
- invokedynamic：JDK1.7新加入的一个虚拟机指令，相比于之前的四条指令，他们的分派逻辑都是固化在JVM内部，而invokedynamic则用于处理新的方法分派：它允许应用级别的代码来确定执行哪一个方法调用，只有在调用要执行的时候，才会进行这种判断,从而达到动态语言的支持。  
Lambda表达式或者反射或者其他动态语言scala kotlin，或者CGLib ASM，动态产生的class，会用到的指令。
1. 非虚方法：invokestatic和invokespecial调用的方法，还有final方法。
#### 分派 
1. 静态分派  
所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作不是由虚拟机来执行的。很多情况下重载版本不是唯一的，只能确定一个更加合适的版本。
2. 动态分派  
在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。应用场景是多态。
3. 单分派与多分派
方法的接收者与方法的参数统称为方法的宗量。  
单分派是根据一个宗量对目标方法进行选择；多分派则是根据多于一个宗量对目标方法进行选择。  
静态多分派；动态单分派。
#### Reflection和MethodHandle
1. Reflection和MethodHandle机制都是在模拟方法调用，但反射是模拟Java代码层次的方法调用，而MethodHandle是在模拟字节码层次的方法调用。MethodHandle的3个方法：findStatic()、findVirtual()、findSpecial()正是对应
invokestatic、invokevirtual&invokeinterface、invokespecial这几条字节码指令的执行权限校验行为，而这些底层细节在使用反射时是不需要关心的。
2. 反射中的java.lang.reflect.Method包含了方法在Java端的全面信息，是重量级的；MethodHandle是轻量级的。
