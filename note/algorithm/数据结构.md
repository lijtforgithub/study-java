## 二叉树
- 中序遍历:左子树——》根节点——》右子树
- 前序遍历:根节点——》左子树——》右子树
- 后序遍历:左子树——》右子树——》根节点

[参考博客](http://www.cnblogs.com/ysocean/p/8032642.html)
删除节点是二叉搜索树中最复杂的操作，删除的节点有三种情况，前两种比较简单，但是第三种却很复杂。
1. 删除没有子节点的节点  
要删除叶节点，只需要改变该节点的父节点引用该节点的值，即将其引用改为 null 即可。要删除的节点依然存在，但是它已经不是树的一部分了，由于Java语言的垃圾回收机制，我们不需要非得把节点本身删掉，一旦Java意识到程序不在与该节点有关联，就会自动把它清理出存储器。  
删除节点，我们要先找到该节点，并记录该节点的父节点。在检查该节点是否有子节点。如果没有子节点，接着检查其是否是根节点，如果是根节点，只需要将其设置为null即可。  
如果不是根节点，是叶节点，那么断开父节点和其的关系即可。
2. 删除有一个子节点的节点  
删除有一个子节点的节点，我们只需要将其父节点原本指向该节点的引用，改为指向该节点的子节点即可。
3. 删除有两个子节点的节点  
当删除的节点存在两个子节点，那么删除之后，两个子节点的位置我们就没办法处理了。既然处理不了，我们就想到一种办法，用另一个节点来代替被删除的节点，那么用哪一个节点来代替呢？  
我们知道二叉搜索树中的节点是按照关键字来进行排列的，某个节点的关键字次高节点是它的中序遍历后继节点。用后继节点来代替删除的节点，显然该二叉搜索树还是有序的。（这里用后继节点代替，如果该后继节点自己也有子节点，我们后面讨论。）那么如何找到删除节点的中序后继节点呢？  
其实我们稍微分析，这实际上就是要找比删除节点关键值大的节点集合中最小的一个节点，只有这样代替删除节点后才能满足二叉搜索树的特性。

后继节点就是：比删除节点大的最小节点。
算法：程序找到删除节点的右节点，(注意这里前提是删除节点存在左右两个子节点，如果不存在则是删除情况的前面两种)，然后转到该右节点的左子节点，依次顺着左子节点找下去，最后一个左子节点即是后继节点；如果该右节点没有左子节点，那么该右节点便是后继节点。  
需要确定后继节点没有子节点，如果后继节点存在子节点，那么又要分情况讨论了。
1. 后继节点是删除节点的右子节点  
这种情况简单，只需要将后继节点表示的子树移到被删除节点的位置即可
2. 后继节点是删除节点的右子节点的左子节点