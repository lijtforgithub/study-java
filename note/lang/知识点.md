- Java程序设计语言总是采用按值调用。
- 不可变字符串优点：编译器可以让字符串共享。
- 浮点数可以除以0，结果Infinity。
- 有些人认为super与this引用是类似的概念，实际上，这样比较并不恰当。这是因为super不是一个对象的引用，不能将super赋给另一个对象变量，它只是指示一个编译器调用超类方法的特殊关键字。如果子类构造器没有显示的调用超类的构造器，则自动地调用超类默认的构造器。如果超类没有不带参数的构造器，并且在子类的构造器重又没有显示的调用超类的其他构造器，则Java编译器将报告错误。
- Java SE 1.4引入了一个标记接口RandomAccess。这个接口没有任何方法，但可以用来检测一个特定的集合是否支持高效的随机访问。
#### String
<font color=red>"" 双引号标记的字符串常量会放入常量池。</font>  
 `String s = new String("XYZ") + new String("XYZ")` JVM先在String池中创建一个String对象存储"XYZ"，然后由于遇到new关键字，再在内存上创建一个String对象存储"XYZ"；接着由于String池中已经有了"XYZ"的对象，所以第二个new语句不会在String池中创建对象，而只会在内存上创建一个String对象；最后两个字符串相加会在String池中创建一个String对象"XYZXYZ"，并将其引用传给s。所以总共会创建4个String对象。
#### 抽象类和接口
- abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。
- 在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员。（也就是必须是static final的，不过在 interface中一般不定义数据成员）。
- abstract class和interface所反映出的设计理念不同。其实abstract class表示的是"is-a"关系，interface表示的是"like-a"关系。
- 实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。
- 接口中定义的变量默认是public static final，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。
- 抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。
## JDK8
#### Lambda表达式与Functional接口
λ表达式本质上是一个匿名方法。只不过这个方法必须符合至少一个函数接口。  
λ表达式有三部分组成：参数列表，箭头（->），以及一个表达式或语句块。  
λ表达式可以被当做是一个Object（注意措辞）。λ表达式的类型，叫做目标类型（target type）。  
λ表达式的目标类型是函数接口（functional interface），这是Java8新引入的概念。  
它的定义是：一个接口，如果只有一个显式声明的抽象方法，那么它就是一个函数接口。一般用@FunctionalInterface标注。
> Comparator接口。它里面声明了两个方法，貌似不符合函数接口的定义，但它的确是函数接口。这是因为equals方法是Object的，所有的接口都会声明Object的public方法——虽然大多是隐式的。所以，Comparator显式的声明了equals不影响它依然是个函数接口。

Lambda可以引用类的成员变量与局部变量（如果这些变量不是final的话，它们会被隐含的转为final，这样效率更高）。如果lambda的函数体只有一行的话，那么没有必要显式使用return语句。

@FunctionalInterface 通过JDK8源码javadoc，可以知道这个注解有以下特点：
1. 该注解只能标记在"有且仅有一个抽象方法"的接口上。
2. JDK8接口中的静态方法和默认方法，都不算是抽象方法。
3. 接口默认继承java.lang.Object，所以如果接口显示声明覆盖了Object中方法，那么也不算抽象方法。
4. 该注解不是必须的，如果一个接口符合"函数式接口"定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了@FunctionInterface，那么编译器会报错。

> 语言设计者投入了大量精力来思考如何使现有的函数友好地支持lambda。最终采取的方法是：增加函数式接口的概念。函数式接口就是一个具有一个方法的普通接口。像这样的接口，可以被隐式转换为lambda表达式。
#### 多种方式生成 Stream Source
1. 从 Collection 和数组
    1. Collection.stream()
    2. Collection.parallelStream()
    3. Arrays.stream(T array) or Stream.of()
2. 从 BufferedReader
    1. java.io.BufferedReader.lines()
3. 静态工厂
    1. java.util.stream.IntStream.range()
    2. java.nio.file.Files.walk()
4. 自己构建
    1. java.util.Spliterator
5. 其它
    1. Random.ints()
    2. BitSet.stream()
    3. Pattern.splitAsStream(java.lang.CharSequence)
    4. JarFile.stream()

.stream操作被分成了中间操作与最终操作这两种。
中间操作返回一个新的stream对象。中间操作总是采用惰性求值方式，运行一个像filter这样的中间操作实际上没有进行任何过滤，相反它在遍历元素时会产生了一个新的stream对象，这个新的stream对象包含原始stream中符合给定谓词的所有元素。  
像forEach、sum这样的最终操作可能直接遍历stream，产生一个结果或副作用。
**当最终操作执行结束之后，stream管道被认为已经被消耗了，没有可能再被使用了**。在大多数情况下，最终操作都是采用及早求值方式，及早完成底层数据源的遍历。