## 类型
Java编程语言是一种强类型化的语言，这意味着每个变量和每个表达式都有一个在编译时已知的类型。类型限制了变量可以保存或者表达式可以产生的值，限制了那些值上支持的操作，并且确定了操作的含义。强类型有助于在编译时检测错误。
- 基本类型有布尔（boolean）型和数值型。数值型有整型byte、short、int、long和char，以及浮点型float和double。
- 引用类型有类类型、接口类型和数组类型。还有一个特殊的空类型。

相应地有两种数据值，即基本值和引用值，它们可以存储在变量中，作为参数传递，被方法返回，并在其上执行各种操作。
- 基本值不与其他基本值共享状态。其类型为基本类型的变量总是保存具有相同类型的基本值。基本类型的变量的值只能通过该变量上的赋值运算进行更改（包括递增递减）。
- 对象是动态创建的类类型的实例或者动态创建的数组。引用类型的值是对对象的引用。所有的对象（包括数组）都支持Object类的方法。
- String类的实例表示Unicode字符序列。String对象具有一个常量（不变的）值。字符串值是对String类的实例的引用。当结果不是一个编译时常量时，字符串串接运算符+会隐式创建一个新的String对象。

程序通常存储为表示编译过的类和接口的二进制文件。这些二进制文件可以加载进Java虚拟机中，链接到其他的类和接口，并进行初始化。
在初始化后，可以使用类的方法和类的变量。可以实例化某些类以创建该类类型的对象。对象是类的实例，也可以包含该类的每个超类的实例，并且对象创建涉及到递归创建这些超类的实例。
当某个对象不再被引用时，就可以用垃圾收集器回收它。如果对象声明了一个终结器（finalizer），在对象被回收前，该终结函数会给对象最后一次机会来清理那些不会被释放的资源。当不需要某个类时，可以卸载它。
虽然所有其他的变量都会被自动初始化一个默认值，但是Java编程语言不会自动化初始化局部变量，以避免掩盖编程错误。
#### 数组
在Java编程语言中，数组是对象，是动态创建的，并且可以赋值给Object类型的变量。类Object的所有方法都可以在数组上被调用。数组类型的变量存储一个指向对象的引用。**声明数组类型的变量不会创建一个数组对象，或者为数组元素分配任何空间。它只会创建变量本身，该变量可以包含一个指向数组的引用。 一旦创建了数组对象，则其长度永远也不会发生改变**。为了使数组变量引用不同长度的数组，必须把指向不同数组的引用赋予该变量。

数组的类名由若干个'['和数组元素类型的内部名称组成，'['的数目代表了数组的维度。**具有相同类型元素和相同维度的数组，属于同一个类**。
如果两个数组的元素类型相同，但维度不同，那么它们也属于不同的类。如果两个数组的元素类型和维度均相同，但长度不同，那么它们还是属于同一个类。

[I这个类是java.lang.Object的直接子类，自身没有声明任何成员变量、成员方法、构造函数和Annotation，可以说，[I就是个空类。连length这个成员变量都没有。 类加载器先看看数组类是否已经被创建了。如果没有，那就说明需要创建数组类(数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的)；如果有，那就无需创建了。如果数组元素是引用类型，那么类加载器首先去加载数组元素的类。JVM根据元素类型和维度，创建相应的数组类。
1. 数组静态分配内存，链表动态分配内存
2. 数组在内存中连续，链表不连续
3. 数组利用下标定位，时间复杂度为O(1)，链表定位元素时间复杂度O(n)
4. 数组插入或删除元素的时间复杂度O(n)，链表的时间复杂度O(1)
> 在java中，数组是一种效率最高的存储和随机访问对象引用序列的方式。
#### 类
类可以通过注释进行修饰，就像任何其他类型的声明一样。类体声明了成员（字段和方法以及嵌套的类和接口）、实例和静态初始化语句，以及构造函数。成员的作用域是该成员所属于的类声明的整个主体。字段、方法、成员类、成员接口的构造函数声明可能包括访问修饰符public、protected或private。类的成员包括声明的和继承的成员。最新声明的字段可以隐藏超类或超接口中声明的字段。最新声明的类成员和接口成员可以隐藏超类或超接口中声明的类或接口成员。最新声明的方法可以隐藏、实现或重写超类或超接口中声明的方法。
 
 并非所有的修饰符都适用于各种类型的类声明。
 - 访问修饰符public仅适用于顶级类和成员类。
 - 访问修饰符protected和private仅适合于直接封闭的类声明内的成员类。
 - 访问修饰符static仅适合于成员类。
 - final类永远不会有任何子类，因此final类的方法永远不会被重写。
 - strictfp修饰符的作用是使类声明内的所有float或double表达式显示地是精确浮点的。这意味着类中声明的所有方法以及类中声明的所有嵌套类型隐式的是strictfp。另外，类的所有变量初始化语句、实例初始化语句、静态初始化语句以及构造函数也是显示地时精确浮点的。
##### 内部类
 内部类可以继承不是编译时常量的静态成员，即使他们不能声明这些成员。依据Java编程语言规范，不是内部类的嵌套类可以自由地声明静态成员。  
**成员接口隐式地总是静态的，因此他们永远不会被视作内部类**。  
**内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两个类**。对于一个名为OuterClass的外部类和其内部定义的名为InnerClass的内部类。编译完成后出现OuterClass.class和OuterClass$InnerClass.class两类。所以内部类的成员变量/方法名可以和外部类的相同。

内部类的对象经常在外部类中创建。但是，也可以从另一个类中创建一个内部类的对象（内部类是非private的）。  
如果该内部类是非静态的，就必须先创建一个外部类的实例，然后使用下面的语法创建一个内部类的对象  
OuterClass outerObject = new OuterClass();  
OuterClass.InnerClass innerObject = outerObject.new InnerClass();  
如果内部类是静态的，那么使用下面的语法为它创建一个对象:  
OuterClass.InnerClass innerObject = new OuterClass.InnerClass();

内部类可以引用定义在它嵌套的外部类中的数据和方法，所以，不需要将外部类对象的引用传递给内部类的的构造方法。成员内部类，就是作为外部类的成员，可以直接使用外部类的所有成员和方法，即使是private的。同时外部类要访问内部类的所有成员变量/方法，则需要通过内部类的对象来获取。要注意的是，成员非静态内部类不能含有static的变量和方法。因为成员内部类需要先创建了外部类，才能创建它自己的。
> 匿名内部类（局部类）来自外部闭包环境的自由变量必须是final的。**外部类可以访问内部类的私有方法**。
#### 枚举
枚举就是一个类，枚举的成员就是类的实例对象。枚举就相当于一个类，其中也可以定义构造方法、成员变量、普通方法和抽象方法。枚举元素必须位于枚举体中最开始部分，枚举元素列表的后面要有分号与其他成员分割。构造方法必须定义成私有的。枚举元素MON和MON()的效果一样，都是调用默认的构造方法。**枚举只有一个成员时，就可以作为一种单例的实现方式**。

枚举类型绝对不能被声明为abstract；否则将导致编译时错误。如果枚举类型E具有一个abstract方法m作为成员，E的所有枚举常量都具有提供了m的具体实现的类体。如果枚举常量的类体声明了一个abstract方法，则会发生编译错误。**枚举类型隐式地是final类型**，它包含至少一个具有类体的枚举常量。无论如何，显示的把枚举类型声明为final会导致编译时报错。
#### 接口
嵌套接口是其声明出现在另一个类或接口的主体内的任何接口。顶级接口是并非嵌套接口的接口。 我们把接口分为两类：普通接口和注释类型。  
访问修饰符protected和private只适合于直接封闭类声明内的成员接口。访问修饰符static只适合于成员接口。  
如果接口用某个名称声明了一个字段，那么就称该字段的声明隐藏了那个接口的超接口中具有相同名称字段的任何和所有可访问的声明。可以通过多途径从一个接口继承相同的字段声明。在这种情形下，将字段视为只会被继承一次，并且可以通过其简单名称无歧义地引用它。
#### 注解
注释（注解）类型是特殊化的接口，用于对声明作注释。这种注释不允许以任何方式影响Java编程语言中的程序语义。  
注解类型不能是泛型。不允许使用extends子句。方法不能有任何参数。方法不能有任何类型参数。方法不能有throws子句。  
**元注解: 元注解是指注解的注解**。包括 @Retention @Target @Document @Inherited四种。
1. @Retention: 定义注解的保留策略。（Java源文件 -> class文件 -> 内存中的字节码。）  
@Retention(RetentionPolicy.SOURCE) 注解仅存在于源码中，在class字节码文件中不包含。  
@Retention(RetentionPolicy.CLASS) 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得。  
@Retention(RetentionPolicy.RUNTIME) 注解会在class字节码文件中存在，在运行时可以通过反射获取到。
2. @Target：定义注解的作用目标。  
@Target(ElementType.TYPE)接口、类、枚举、注解。  
@Target(ElementType.FIELD)字段、枚举的常量。  
@Target(ElementType.METHOD)方法。  
@Target(ElementType.PARAMETER)方法参数。  
@Target(ElementType.CONSTRUCTOR)构造函数。  
@Target(ElementType.LOCAL_VARIABLE)局部变量。  
@Target(ElementType.ANNOTATION_TYPE)注解。  
@Target(ElementType.PACKAGE)包 ElementType 可以有多个，一个注解可以为类的，方法的，字段的等等。
3. @Document：说明该注解将被包含在javadoc中。
4. @Inherited：说明子类可以继承父类中的注解。
> 使用注解时：如果注解的属性是数组，只传入一个元素，这时候属性值部分可以省略大括号。
#### 泛型
泛型是指参数化类型的能力。since JDK1.5  
可以定义带泛型类型的接口、类、方法。 优点是能够在编译时而不是在运行时检测出错误。按照惯例，像E或T这样的单个大写字母用于表示一个形式泛型类型。泛型类型必须是引用类型。  
- 定义泛型类或接口：将泛型类型放在类名或接口名之后 `className<E> InterfaceName<E>`。
- 定义泛型方法：将泛型类型放在方法返回类型之前 `<E> void methodName(E o1, Eo2)`。
- 受限泛型：将泛型指定为另一种类型的子类型。
- 通配类型有三种形式：? 、? extends T 、? super T  
 非受限通配?和 ? extends Object 是一样的；受限通配? extends T，表示T或T的一个未知子类型；下限通配? super T，表示T或T的一个未知父类型。

泛型是使用一种称为类型消除的方法来实现的。编译器使用泛型类型信息来编译代码，但是随后会消除它。因此，泛型信息在运行时是不可用的。这中方法使泛型代码向后兼用使用原始类型的遗留代码。  
**泛型存在于编译时**。一旦编译器确认泛型类型是安全使用的，就会将它转换为原始类型。 当编译泛型类、接口、方法时，编译器用Object类型代替泛型类型。如果一个泛型是受限的，那么编译器就会用一个受限类型来替换它。  
不管实际的具体类型是什么，泛型类是被它的所有实例所共享的。  
`ArrayList<String> list1 = new ArrayList<>(); `  
`ArrayList<Integer> list2 = new ArrayList<>();`  
尽管在编译时`ArrayList<String>`和`ArrayList<Integer>`是两种类型，但是，在运行时只有一个ArrayList类会被加载到JVM中。

由于泛型类型在运行时被消除，有以下限制： 
1. 不能使用new E()，不能使用泛型类型参数创建实例。E object = new E();是错误的，因为运行时泛型类型E不可用的。
2. 不能`new E[]`，不能使用泛型类型参数创建数组。`E elements = new E[capacity]`; 是错误的。可以通过创建一个Object类型的数组。`E elements = (E[])new Object[capacity]`; 会导致一个免检的编译警告。
3. **在静态环境下不允许类的参数是泛型类型**。由于泛型类的所有实例都有相同的运行时的类，所以泛型类的静态变量和方法是被它的所有实例所共享的。因此，在静态方法、数据域或者初始化语句中，为了类而引用泛型类型参数是非法的。（所有实例共享的，用哪一个具体的类替换泛型都是矛盾的）。
4. 异常类不能是泛型的。因为JVM必须检查抛出的异常与catch字句中指定的类型匹配。但泛型信息在运行时是不可用的。
#### 反射
*反射就是把Java类中的各种成分映射成相应的Java类。*  
如果底层方法是静态的，那么可以忽略指定的obj参数。该参数可以为null。 如果底层方法所需的形参数为0，则所提供的args数组长度可以为0或null。
如果方法正常完成，则将该方法返回的值返回给调用者；如果该值为基本类型，则首先适当地将其包装在对象中。
但是，如果该值的类型为一组基本类型，则数组元素不被包装在对象中；换句话说，将返回基本类型的数组。 如果底层方法返回类型为void，则该调用返回null。

启动Java程序的main方法的参数是一个字符串数组，即`public static void main(String[] args)`，通过反射方式来调用这个main方法时，如何为invoke方法传递参数呢？  
按JDK1.5的语法，整个数组是一个参数，而按JDK1.4的语法，数组中的每个元素对应一个参数，当把一个字符串数组作为参数传递给invoke方法是，javac会到底按照哪种语法处理呢？
JDK1.5肯定要兼容JDK1.4的语法，会按JDK1.4的语法进行处理，即把数组打散成为若干个单独的参数。所以，在给main方法传递参数时，不能使用代码  
`mainMethod.invoke(null, new String[]{"xxx"})`  
javac只把它当作JDK1.4的语法进行理解，而不把它当作JDK1.5的语法解释，因此会出现参数类型不对的问题。
解决办法：  
`mainMethod.invoke(null, new Object[]{new String[]{"xxx"}})`  
`mainMethod.invoke(null, (Object)new String[]{"xxx"})`  
编译器会做特殊处理，编译时不把参数当作数组看待，也就不会数组打散成若干个参数了。  
`public static List asList(Object[] a)` - JDK1.4    
`public static <T> List<T> asList(T... a)` - JDK1.5  
如果是基本类型的数组则会用JDK1.5的语法作为一个参数放进List，所以打印的话会是一个数组地址。`[[I@1c313da]`  
如果是引用类型的话会兼容JDK1.4的语法，如果是字符串，打印的如：`[hello, world, from, java]`

## Class 类型名
如果此类对象表示一个基本类型或 void，则返回的名字是一个与该基本类型或 void 所对应的 Java 语言关键字相同的 String。如果此类对象表示一个数组类，则名字的内部形式为：表示该数组嵌套深度的一个或多个 '[' 字符加元素类型名。元素类型名的编码如下：

| 元素类型 | 编码 |
|---|---|
| boolean | Z |
| byte | B |
| char | C |
| double | D |
| float | F |
| int | I |
| long | J |
| short | S |
| class / interface | Lclassname |
| 示例 | 示例 |
| String.class.getName() | java.lang.String |
| byte.class.getName() | byte |
| (new Object[3]).getClass().getName() | [Ljava.lang.Object |
| (new int[3][4][5][6][7][8][9]).getClass().getName() | [[[[[[[I |

## 特性
#### 1.封装
- 良好的封装能够减少耦合。
- 类内部的结构可以自由修改。
- 可以对成员进行更精确的控制。
- 隐藏信息，实现细节。
> 封装确实可以使我们容易地修改类的内部实现，而无需修改使用了该类的客户代码。可以对成员变量进行更精确的控制。
#### 2.继承
继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。	继承定义了类如何相互关联，共享特性。
- 子类拥有父类非private的属性和方法。
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。

除了那些private的外还有一样是子类继承不了的-构造器。对于构造器而言，它只能够被调用，而不能被继承。调用父类的构造方法我们使用super()即可。在构造器中调用父类构造器来完成初始化，而父类构造器具有执行父类初始化所需要的所有知识和能力。  
编译器会默认给子类调用父类的构造器。这个默认调用父类的构造器是有前提的：父类有默认构造器。如果父类没有默认构造器，我们就要必须显示的使用super()来调用父类构造器，否则编译器会报错：无法找到符合父类形式的构造器。  
对于继承，子类会默认调用父类的构造器，但是如果没有默认的父类构造器，子类必须要显示的指定父类的构造器，而且必须是在子类构造器中做的第一件事(第一行代码)。

尽管可以使用protected访问修饰符来限制父类属性和方法的访问权限，但是最好的方式还是将属性保持为private（我们应当一致保留更改底层实现），通过protected方法来控制类的继承者的访问权限。继承存在如下缺陷：
- 父类变，子类就必须变。
- 继承破坏了封装，对于父类而言，它的实现细节对与子类来说都是透明的。
- 继承是一种强耦合关系。  
> 《Think in java》中提供了解决办法：问一问自己是否需要从子类向父类进行向上转型。如果必须向上转型，则继承是必要的，但是如果不需要，则应当好好考虑自己是否需要继承。

> 向上转型：通俗地讲即是将子类对象转为父类对象。此处父类对象可以是接口。向上转型存在一些缺憾，那就是它必定会导致一些方法和属性的丢失，而导致我们不能够获取它们。所以父类类型的引用可以调用父类中定义的所有属性和方法，对于只存在与子类中的方法和属性它就望尘莫及了。
向下转型：与向上转型相反，即是把父类对象转为子类对象。不安全的向下转型,编译无错但会运行会出错。（可以通过instanceof来防止出现异常）
#### 3.多态	
多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。	因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。

指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。
	
Java实现多态有三个必要条件：继承、重写、向上转型。
- 继承：在多态中必须存在有继承关系的子类和父类。
- 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。
- 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。

当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。
> 在Java中有两种形式可以实现多态。继承和接口。基于继承的实现机制主要表现在父类和继承该父类的一个或多个子类对某些方法的重写，多个子类对同一方法的重写可以表现出不同的行为。当子类重写父类的方法被调用时，只有对象继承链中的最末端的方法才会被调用。
